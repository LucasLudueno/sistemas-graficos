<!doctype html>
<meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
<meta content="ISO-8859-1" http-equiv="encoding">
<html>
<head>
    <title>Sistemas Graficos TP</title>
    <style>
        body {
            background-color: grey;
        }
        canvas {
            background-color: white;
        }
        textarea {
            background-color: black;
            foreground-color: white;
        }
    </style>

    <!-- Libraries -->
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript" src="webgl-utils.js"></script>

    <!-- Scrips -->
    <script type="text/javascript" src="main.js"></script>
    <script type="text/javascript" src="VertexGrid.js"></script>
    <script type="text/javascript" src="Plane.js"></script>
    <script type="text/javascript" src="Cilindro.js"></script>
    <script type="text/javascript" src="Esfera.js"></script>
    <script type="text/javascript" src="SupBarrido.js"></script>
    <script type="text/javascript" src="ClosedExtrusion.js"></script>
    <script type="text/javascript" src="SupRevolucion.js"></script>
    <script type="text/javascript" src="Vertex.js"></script>
    <script type="text/javascript" src="SpaceStation.js"></script>
    <script type="text/javascript" src="SpaceStationCargoBay.js"></script>
    <script type="text/javascript" src="SpaceStationCargoBayCover.js"></script>
    <script type="text/javascript" src="SpaceStationCenter.js"></script>
    <script type="text/javascript" src="SpaceStationCabin.js"></script>
    <script type="text/javascript" src="CurvaBezierCubica.js"></script>
    <script type="text/javascript" src="TexturedSphere.js"></script>
    <script type="text/javascript" src="Camera.js"></script>
    <script type="text/javascript" src="SolarPanelBlock.js"></script>
    <script type="text/javascript" src="SolarPanelWing.js"></script>
    <script type="text/javascript" src="NaveVidrio.js"></script>
    <script type="text/javascript" src="NaveCasco.js"></script>
    <script type="text/javascript" src="NaveWing.js"></script>
    <script type="text/javascript" src="NaveLegs.js"></script>
    <script type="text/javascript" src="NaveLeg.js"></script>
    <script type="text/javascript" src="NaveCompleteWing.js"></script>
    <script type="text/javascript" src="NaveWingWithTurbin.js"></script>
    <script type="text/javascript" src="NaveTurbin.js"></script>
    <script type="text/javascript" src="Nave.js"></script>
    <script type="text/javascript" src="CurvaBSpline.js"></script>
    <script type="text/javascript" src="MangueraAstronauta.js"></script>
    <script type="text/javascript" src="Background.js"></script>
    <script type="text/javascript" src="jquery-1.9.1.js"></script>


    <!-- Shaders -->
    <script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
	attribute vec3 aVertexTangent;
	attribute vec3 aVertexBinormal;

    attribute vec2 aTextureCoord;

    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform bool uUseLighting;
    uniform bool uUseReflection;

    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;

    varying vec3 vertPos;
	varying vec3 reflectDir;

	varying vec3 normalInterp;
	varying vec3 tangentInterp;
	varying vec3 binormalInterp;

    void main(void) {

		// Transformamos al vértice al espacio de la cámara
		vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

		// Transformamos al vértice al espacio de la proyección
        gl_Position = uPMatrix * pos_camera_view;

    	vertPos = vec3(pos_camera_view) / pos_camera_view.w;

		// Coordenada de textura sin modifiaciones
        vTextureCoord = aTextureCoord;

        normalInterp = normalize(uNMatrix * aVertexNormal);
        tangentInterp = normalize(uNMatrix * aVertexTangent);
        binormalInterp = normalize(uNMatrix * aVertexBinormal);

		if (uUseReflection) {
    			vec3 view = normalize(vertPos);
    			reflectDir = reflect(view, normalInterp);
    			reflectDir = vec3(uViewMatrix * vec4(reflectDir, 0.0));
    	}
    }



    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;

        uniform bool uUseReflection;
        uniform bool uUseNormalMap;
        uniform float uReflectFactor;

        uniform sampler2D uSampler;
        uniform sampler2D uReflectionSampler;
        uniform sampler2D uNormalSampler;

        uniform vec3 uAmbientColor;
        uniform vec3 uLightPosition;
        uniform vec3 uDirectionalColor;

        varying vec3 reflectDir;

        varying vec3 normalInterp;
        varying vec3 tangentInterp;
        varying vec3 binormalInterp;

        varying vec3 vertPos;

        void main(void) {
        vec3 normal = normalize(normalInterp);
        vec3 tangent = normalize(tangentInterp);
        vec3 binormal = normalize(binormalInterp);

        if (uUseNormalMap) {
            mat3 tbn = mat3(tangent, binormal, normal);
            vec3 normalCoordinate = texture2D(uNormalSampler, vec2(vTextureCoord.s, vTextureCoord.t)).xyz * 2.0 - 1.0;
            normal = normalize(tbn * normalCoordinate);
        }

        ////////////////////////////////////////////
        // Calculos de la iluminación
        vec3 lightDir = uLightPosition - vertPos;
        vec3 lightReflectDir = reflect(-lightDir, normal);
        vec3 viewDir = normalize(-vertPos);

        float directionalLightWeighting = max(dot(lightDir,normal), 0.0);
        float specular = 0.0;

        if(directionalLightWeighting > 0.0) {
        float specAngle = max(dot(lightReflectDir, viewDir), 0.0);
        //specular = pow(specAngle, uMaterial.Shininess);
        }
        vec3 vLightWeighting = uAmbientColor + uDirectionalColor *directionalLightWeighting; // specular??

        normalize(lightDir);

        //vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
        //float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
        //vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
        ////////////////////////////////////////////

        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);

        if (uUseReflection) {
        vec2 reflectDir2D = vec2(reflectDir.x,reflectDir.y);
        vec4 enviromentColor = texture2D(uReflectionSampler, reflectDir2D ); /*rever lo de reflectdir2d */
        gl_FragColor = vec4(mix(textureColor, enviromentColor, uReflectFactor).rgb * vLightWeighting, textureColor.a);
        }
        }


    </script>
</head>


<body onload="webGLStart()">
<center>
    <h1>Sistemas Graficos - TP </h1>
    <h2>Ludueno Lucas - Horacio Martinez</h2>
    <b> <font color="white">Paneles solares: </font></b>abrir: O, cerrar: P
    <br>
    <b> <font color="white">Camaras: </font></b>orbital 1, bahia de carga: 2, cabina nave: 3, persecucion nave: 4
    <br>
    <b> <font color="white">Movimiento nave: </font></b>WASD rotar, + - acelerar (debe estar en camaras 3 o 4), R:
    cerrar patas, T: desplegar patas
    <canvas id="tp-canvas" width="1280" height="720">
        Your browser does not support the HTML5 canvas element.
    </canvas>
</center>
</body>
</html>
